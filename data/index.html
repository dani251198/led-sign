<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Agentur-für-Felix</title>
  <style>
    :root { color-scheme: light; }
    body { font-family: system-ui, sans-serif; margin: 16px; background: #f4f6fb; color: #0f172a; }
    h1 { margin-bottom: 4px; }
    .sub { color: #475569; margin-top: 0; }
    fieldset { margin-bottom: 16px; border: 1px solid #d5d7e0; padding: 12px 14px; border-radius: 10px; background: #ffffff; box-shadow: 0 1px 2px rgba(0,0,0,0.04); }
    legend { padding: 0 6px; font-weight: 600; }
    label { display: block; margin: 8px 0; font-size: 14px; color: #0f172a; }
    input[type="text"], input[type="number"], select { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #cfd2dc; border-radius: 6px; color: #0f172a; background: #fff; }
    input[type="range"] { width: 100%; }
    input::placeholder { color: #94a3b8; }
    button { padding: 8px 12px; border-radius: 6px; border: 1px solid #c0c4d3; background: #fff; cursor: pointer; color: #0f172a; }
    button:hover { background: #eef1f9; }
    .btn-primary { background: #2563eb; border-color: #1d4ed8; color: #fff; }
    .btn-primary:hover { background: #1d4ed8; }
    .btn-danger:hover { background: #fecaca; border-color: #ef4444; color: #991b1b; }
    .row { display: grid; grid-template-columns: repeat(auto-fit,minmax(160px,1fr)); gap: 8px; }
    .grid-panels { display: grid; grid-template-columns: repeat(auto-fit,minmax(280px,1fr)); gap: 12px; }
    .inline { display: inline-flex; align-items: center; gap: 8px; }
    .inline-ical { display:flex; align-items:center; gap:8px; flex-wrap:nowrap; }
    .inline-ical .ical-color { width:52px; height:36px; padding:0; border:none; background:transparent; flex:0 0 auto; }
    .ical-row { display:flex; gap:8px; align-items:center; }
    .ical-row input[type="text"] { flex:1; min-width:0; }
    .mode-options { display:flex; gap:8px; flex-wrap:wrap; }
    .mode-pill { display:inline-flex; align-items:center; gap:6px; padding:8px 12px; border:1px solid #cfd2dc; border-radius:20px; background:#fff; cursor:pointer; }
    .mode-pill input { margin:0; }
    .mode-pill.active { border-color:#2563eb; background:#e3edff; }
    ul { padding-left: 18px; }
    .actions { display: flex; justify-content: flex-end; margin-top: 12px; }
    .hidden { display: none; }
    .topbar { display:flex; justify-content:space-between; align-items:flex-start; gap:12px; }
    .clockblock { text-align:right; }
    #clockNow { font-size: 22px; font-weight: 700; }
    #dateNow { font-size: 16px; color:#475569; }
    .led-preview { position: relative; width: 210px; height: 150px; margin: 12px 0 18px; background: #e7ecf5; border: 1px solid #d5d7e0; border-radius: 10px; }
    .led-dot { position: absolute; width: 16px; height: 16px; border-radius: 50%; background: #d1d5db; box-shadow: 0 0 6px rgba(0,0,0,0.15); transition: background-color 0.2s ease, filter 1s linear; }
    .led-preview.animate-rainbow .led-dot { animation: hue-cycle 2.4s linear infinite; }
    @keyframes hue-cycle { from { filter: hue-rotate(0deg); } to { filter: hue-rotate(360deg); } }
  </style>
</head>
<body>
  <h1>Agentur-für-Felix</h1>
  <p class="sub">Webpanel zum Steuern von Farben, Helligkeit, Zeiten, Terminen und Updates.</p>
  <div class="topbar">
    <p class="sub" style="margin:0;">Status: <span id="status">laden...</span> · Version: <span id="fwVersion">--</span></p>
    <div class="clockblock">
      <div id="clockNow">--:--</div>
      <div id="dateNow">--.--.----</div>
    </div>
  </div>

  <div>
    <strong>LED-Vorschau</strong>
    <div id="ledPreview" class="led-preview"></div>
  </div>

  <form id="cfgForm">
    <div class="grid-panels">
      <fieldset>
        <legend>Modus &amp; Helligkeit</legend>
        <label>Helligkeit <span id="brightnessLabel">60%</span>
          <input type="range" name="brightness" min="0" max="100" value="60">
        </label>
        <div class="mode-options" role="radiogroup" aria-label="Modus">
          <label class="mode-pill"><input type="radio" name="mode" value="clock"> Uhr</label>
          <label class="mode-pill"><input type="radio" name="mode" value="effect"> Effekt</label>
        </div>
        <label class="mode-effect">Effekt
          <select name="effect">
            <option value="rainbow">Rainbow</option>
            <option value="solid">Solid</option>
            <option value="breathe">Breathe</option>
            <option value="theater">Theater Chase</option>
            <option value="twinkle">Twinkle</option>
            <option value="xmas">Xmas Lights</option>
          </select>
        </label>
        <label class="mode-effect effect-speed">Effekt-Geschwindigkeit <span id="effectSpeedLabel">4</span>
          <input type="range" name="effectSpeed" min="1" max="20" value="4">
        </label>
      </fieldset>

      <fieldset>
        <legend>Farben</legend>
        <label><input type="color" name="openColor"> Agentur für Arbeit - Offen</label>
        <label><input type="color" name="closedColor"> Agentur für Arbeit - Geschlossen</label>
        <label><input type="color" name="clockColor"> Uhr</label>
        <label><input type="color" name="effectColor"> Effektfarbe</label>
      </fieldset>
    </div>

    <div class="grid-panels">
      <fieldset>
        <legend>Logik &amp; Priorität</legend>
        <p style="margin:0 0 8px; color:#475569; font-size:13px;">Termin hat höchste Priorität (überschreibt Effekt/Uhr). Öffnungszeiten können Uhr-Farbe übersteuern. Effekt ist exklusiv und deaktiviert Öffnungszeiten.</p>
        <label><input type="checkbox" name="enableAppointments" checked> Termine aktiv (überschreiben Effekt/Uhr)</label>
        <label><input type="checkbox" name="enableOpenHours" checked> Öffnungszeiten aktiv (ersetzt Uhr-Farbe bei offen/zu)</label>
      </fieldset>

      <fieldset id="hoursFieldset">
        <legend>Zeiten</legend>
        <label>Zeitzone (POSIX) <input type="text" name="tz"></label>
        <div class="row" id="hours"></div>
        <small>Format HH:MM-HH:MM, Start Montag</small>
      </fieldset>
    </div>

    <fieldset>
      <legend>Termine</legend>
        <label>iCal Kalender</label>
        <div style="padding:8px; margin:4px 0 8px; border:1px solid #fca5a5; background:#fef2f2; color:#991b1b; border-radius:6px; font-size:13px;">
          Hinweis: iCal-Termine funktionieren aktuell nicht.
        </div>
      <div id="icalList" class="vstack" style="display:flex; flex-direction:column; gap:8px; margin-bottom:8px;"></div>
      <div class="inline-ical">
        <input type="text" id="newIcalUrl" placeholder="https://..." style="flex:1; min-width:0;">
        <input type="color" id="newIcalColor" value="#00ffff" title="Farbe" class="ical-color">
        <button type="button" id="btnAddIcal">Hinzufügen</button>
      </div>
      <small style="color:#475569;">Bis zu 5 Kalender. Jeder Termin verwendet seine Kalenderfarbe. Nächste Termine je Kalender siehe unten.</small>
      <label>Vorwarnzeit (Minuten vor Termin)
        <input type="number" name="notifyMinutesBefore" min="0" max="1440" value="30">
      </label>
      <label>Neuer Termin (deutsches Format: TT.MM.JJJJ HH:MM)
        <div style="display:flex; gap:8px; align-items:center;">
          <input type="text" id="newAppointment" style="flex:1;" placeholder="24.12.2025 10:30">
          <input type="color" id="newAppointmentColor" value="#00ffff" title="Farbe" style="width:64px; height:36px; padding:0; border:none; background:transparent;">
          <button type="button" id="btnAddAppt">Hinzufügen</button>
        </div>
      </label>
      <div id="apptList"></div>
        <div id="icalNext" style="margin-top:10px; color:#0f172a; font-size:14px;"></div>
    </fieldset>

    <div class="actions">
      <button type="submit" class="btn-primary">Speichern</button>
    </div>
  </form>

  <fieldset>
    <legend>OTA Update</legend>
    <div style="margin-top:10px; padding:10px; border:1px solid #e2e8f0; border-radius:8px; background:#f8fafc;">
      <div class="inline" style="gap:8px;">
        <strong>Release</strong>
        <button type="button" id="btnReleaseInfo">Aktualisieren</button>
        <button type="button" id="btnReleaseFlash" class="btn-primary">Neueste Release flashen (FW+FS)</button>
      </div>
      <div id="releaseInfo" style="margin-top:8px; font-size:14px; color:#0f172a; white-space:pre-wrap;">Noch nicht geladen.</div>
      <div id="updateStatus" class="hidden" style="margin-top:6px; font-size:13px; color:#0f172a; white-space:pre-wrap;">Update-Status</div>
      <div id="updateProgress" class="hidden" style="margin-top:4px; font-size:12px; color:#475569;"></div>
    </div>
  </fieldset>

  <fieldset>
    <legend>WLAN</legend>
    <p>Setzt gespeicherte WLAN-Zugangsdaten zurück und startet das Gerät neu. Danach erscheint wieder das Setup-WLAN.</p>
    <button id="btnWifiReset" type="button">WLAN zurücksetzen</button>
  </fieldset>

  <script>
    const hoursContainer = document.getElementById('hours');
    const hoursFieldset = document.getElementById('hoursFieldset');
    const statusEl = document.getElementById('status');
    const apptListEl = document.getElementById('apptList');
    const brightnessLabel = document.getElementById('brightnessLabel');
    const modeRadios = Array.from(document.querySelectorAll('input[name="mode"]'));
    const effectSelect = document.querySelector('select[name="effect"]');
    const effectSpeedLabel = document.getElementById('effectSpeedLabel');
    const releaseInfo = document.getElementById('releaseInfo');
    const btnReleaseInfo = document.getElementById('btnReleaseInfo');
    const btnReleaseFlash = document.getElementById('btnReleaseFlash');
    const clockNowEl = document.getElementById('clockNow');
    const dateNowEl = document.getElementById('dateNow');
    const fwVersionEl = document.getElementById('fwVersion');
    const updateStatusEl = document.getElementById('updateStatus');
    const updateProgressEl = document.getElementById('updateProgress');
    const icalListEl = document.getElementById('icalList');
    const newIcalUrl = document.getElementById('newIcalUrl');
    const newIcalColor = document.getElementById('newIcalColor');
    const icalNextEl = document.getElementById('icalNext');
    let autoSaveTimer;
    let isLoadingConfig = false;
    let latestConfig;
    let latestStatus;
    let icalEntries = [];
    const ledPreview = document.getElementById('ledPreview');
    const LED_COUNT = 12;
    let previewHue = 0;
    let previewChase = 0;
    let previewTwinkle = new Array(LED_COUNT).fill({r:0,g:0,b:0});
    let previewInterval = null;

    const dayOrder = [1,2,3,4,5,6,0];
    function dayLabel(idx){
      return ['So','Mo','Di','Mi','Do','Fr','Sa'][idx];
    }

    function getSelectedMode(){
      const checked = modeRadios.find(r=>r.checked);
      return checked ? checked.value : 'clock';
    }

    function syncModePills(){
      modeRadios.forEach(radio=>{
        const label = radio.closest('.mode-pill');
        if(label){
          label.classList.toggle('active', radio.checked);
        }
      });
    }

    function updateModeVisibility(){
      const mode = getSelectedMode();
      const effect = effectSelect.value;
      const openChk = document.querySelector('input[name="enableOpenHours"]');
      document.querySelectorAll('.mode-effect').forEach(el=>{
        el.classList.toggle('hidden', mode !== 'effect');
      });
      document.querySelectorAll('.mode-status').forEach(el=>{
        el.classList.toggle('hidden', false);
      });
      document.querySelectorAll('.mode-clock').forEach(el=>{
        el.classList.toggle('hidden', false);
      });
      const showHours = mode !== 'effect' && (!openChk || openChk.checked !== false);
      hoursFieldset.classList.toggle('hidden', !showHours);
      const needsSpeed = effect !== 'solid';
      document.querySelectorAll('.effect-speed').forEach(el=>{
        el.classList.toggle('hidden', !(mode === 'effect' && needsSpeed));
      });
      if(openChk){
        openChk.disabled = mode === 'effect';
        openChk.parentElement.style.opacity = mode === 'effect' ? 0.5 : 1;
      }
      // Termin-Bereich bleibt immer sichtbar.
      syncModePills();
    }

    function buildHours(fields){
      hoursContainer.innerHTML = '';
      dayOrder.forEach(idx => {
        const wrap = document.createElement('div');
        const label = document.createElement('label');
        label.textContent = `${dayLabel(idx)} (HH:MM-HH:MM)`;
        const inp = document.createElement('input');
        inp.type = 'text';
        inp.name = `h${idx}`;
        inp.placeholder = '08:00-16:00';
        if(fields && fields[idx]) inp.value = `${fields[idx].start}-${fields[idx].end}`;
        label.appendChild(inp);
        wrap.appendChild(label);
        hoursContainer.appendChild(wrap);
      });
    }

    function ensureLedDots(){
      if(ledPreview.childElementCount === 12) return;
      ledPreview.innerHTML = '';
      const coords = [
        {x:0,y:120},{x:20,y:100},{x:40,y:80},{x:60,y:60},{x:80,y:40},{x:100,y:20}, // 6 nach oben rechts
        {x:120,y:40},{x:140,y:60},{x:160,y:80},{x:180,y:100}, // 4 nach unten rechts
        {x:160,y:120},{x:140,y:120} // 2 nach links (waagrecht)
      ];
      coords.forEach((c, idx)=>{
        const d = document.createElement('div');
        d.className = 'led-dot';
        d.style.left = `${c.x}px`;
        d.style.top = `${c.y}px`;
        d.dataset.idx = idx;
        ledPreview.appendChild(d);
      });
    }

    function renderIcalList(){
      icalListEl.innerHTML = '';
      if(!icalEntries || icalEntries.length === 0){
        const empty = document.createElement('div');
        empty.textContent = 'Keine Kalender hinterlegt.';
        empty.style.color = '#475569';
        icalListEl.appendChild(empty);
        return;
      }
      icalEntries.forEach((entry, idx)=>{
        const row = document.createElement('div');
        row.className = 'ical-row';
        const url = document.createElement('input');
        url.type = 'text';
        url.value = entry.url || '';
        url.placeholder = 'https://...';
        url.addEventListener('input', ()=>{
          icalEntries[idx].url = url.value.trim();
          scheduleAutoSave();
        });
        const color = document.createElement('input');
        color.type = 'color';
        color.className = 'ical-color';
        color.value = `#${(entry.color || '00ffff')}`;
        color.addEventListener('input', ()=>{
          icalEntries[idx].color = color.value.replace('#','');
          scheduleAutoSave();
        });
        const del = document.createElement('button');
        del.type = 'button';
        del.textContent = 'Löschen';
        del.className = 'btn-danger';
        del.addEventListener('click', ()=>{
          icalEntries.splice(idx,1);
          renderIcalList();
          scheduleAutoSave();
        });
        row.appendChild(url);
        row.appendChild(color);
        row.appendChild(del);
        icalListEl.appendChild(row);
      });
    }

    function renderIcalNext(){
      icalNextEl.innerHTML = '';
      const next = latestStatus?.icalNext;
      if(!next || !Array.isArray(next) || next.length === 0){
        icalNextEl.textContent = 'Keine iCal-Daten geladen.';
        icalNextEl.style.color = '#475569';
        return;
      }
      const list = document.createElement('ul');
      next.forEach(entry => {
        const li = document.createElement('li');
        const color = document.createElement('span');
        color.style.display = 'inline-block';
        color.style.width = '12px';
        color.style.height = '12px';
        color.style.borderRadius = '3px';
        color.style.background = `#${entry.color || '00ffff'}`;
        color.style.marginRight = '6px';
        li.appendChild(color);
        const ts = entry.next ? new Date(entry.next * 1000) : null;
        const dateStr = ts ? ts.toLocaleString('de-DE', {weekday:'short', day:'2-digit', month:'2-digit', hour:'2-digit', minute:'2-digit'}) : 'kein Termin gefunden';
        const urlLabel = (entry.url || '').replace(/^https?:\/\//,'');
        li.appendChild(document.createTextNode(`${urlLabel || 'Kalender'}: ${dateStr}`));
        list.appendChild(li);
      });
      icalNextEl.appendChild(list);
    }

    function hexToCss(hex){
      const h = (hex || 'cccccc').padStart(6,'0');
      return `#${h}`;
    }

    function hexToRgb(hex){
      const h = (hex || '000000').padStart(6,'0');
      const r = parseInt(h.slice(0,2),16);
      const g = parseInt(h.slice(2,4),16);
      const b = parseInt(h.slice(4,6),16);
      return {r,g,b};
    }

    function rgbToCss({r,g,b}){
      return `rgb(${Math.round(r)},${Math.round(g)},${Math.round(b)})`;
    }

    function hsvToCss(h,s,v){
      const f = (n)=>{
        const k = (n + h/60) % 6;
        return v - v*s*Math.max(Math.min(k,4-k,1),0);
      };
      const r = Math.round(f(5)*255);
      const g = Math.round(f(3)*255);
      const b = Math.round(f(1)*255);
      return rgbToCss({r,g,b});
    }

    function stopPreviewLoop(){
      if(previewInterval){
        clearInterval(previewInterval);
        previewInterval = null;
      }
    }

    function updateLedPreview(){
      ensureLedDots();
      const cfg = latestConfig;
      if(!cfg){ return; }
      const st = latestStatus;

      stopPreviewLoop();
      const dots = ledPreview.querySelectorAll('.led-dot');

      function applyStatic(colorHex){
        const css = hexToCss(colorHex);
        dots.forEach(d => { d.style.backgroundColor = css; });
      }

      if(cfg.mode !== 'effect'){
        // Clock preview: progressive fill over 12h
        const now = new Date();
        const hours12 = (now.getHours() % 12) + now.getMinutes()/60;
        const pos = (hours12 / 12) * LED_COUNT;
        const full = Math.floor(pos);
        const frac = pos - full;
        let baseHex = cfg.clockColor || 'ffffff';
        if(cfg.enableOpenHours && st){
          const open = st.open;
          baseHex = open ? (cfg.openColor || '00ff00') : (cfg.closedColor || 'ff0000');
        }
        const baseCss = hexToCss(baseHex);
        dots.forEach((d, idx)=>{
          if(idx < full){
            d.style.backgroundColor = baseCss;
          } else if(idx === full){
            const c = hexToRgb(baseHex);
            const scale = Math.max(0, Math.min(1, frac));
            const scaled = {r: c.r*scale, g: c.g*scale, b: c.b*scale};
            d.style.backgroundColor = rgbToCss(scaled);
          } else {
            d.style.backgroundColor = '#000000';
          }
        });
        return;
      }

      // Effect preview: mirror firmware logic
      const step = Math.max(1, Math.min(20, cfg.effectSpeed || 4));
      const eff = cfg.effect || 'rainbow';
      if(eff === 'solid'){
        applyStatic(cfg.effectColor || 'ffffff');
        return;
      }

      previewInterval = setInterval(()=>{
        const speedVal = Math.max(1, Math.min(20, cfg.effectSpeed || 4));
        if(eff === 'rainbow'){
          previewHue = (previewHue + step) % 256;
          dots.forEach((d, idx)=>{
            const hue = ((previewHue + idx*3) % 256) * (360/255);
            d.style.backgroundColor = hsvToCss(hue,1,1);
          });
        } else if(eff === 'theater'){
          const stepMs = ((250 - 40) * (20 - speedVal) / 19) + 40; // map 1..20 -> ~250..40
          const nowTs = performance.now();
          if(!previewInterval._lastTheaterTs) previewInterval._lastTheaterTs = nowTs;
          if(nowTs - previewInterval._lastTheaterTs >= stepMs){
            previewInterval._lastTheaterTs = nowTs;
            previewChase = (previewChase + 1) % 3;
          }
          const color = hexToCss(cfg.effectColor || 'ffffff');
          const offset = previewChase % 3;
          dots.forEach((d, idx)=>{
            d.style.backgroundColor = (idx % 3 === offset) ? color : '#000000';
          });
        } else if(eff === 'twinkle'){
          // fade existing
          previewTwinkle = previewTwinkle.map(c=>({
            r: Math.max(0, c.r - 20),
            g: Math.max(0, c.g - 20),
            b: Math.max(0, c.b - 20)
          }));
          // random sparkles
          const chance = Math.max(1, step);
          const colorRgb = hexToRgb(cfg.effectColor || 'ffffff');
          for(let i=0;i<LED_COUNT;i++){
            if(Math.random()*255 < chance){
              previewTwinkle[i] = {...colorRgb};
            }
          }
          dots.forEach((d, idx)=>{ d.style.backgroundColor = rgbToCss(previewTwinkle[idx]); });
        } else if(eff === 'breathe'){
          const bpm = ((step - 1) * (30 - 6) / (20 - 1)) + 6; // map 1-20 -> 6-30
          const now = performance.now();
          const phase = (now * bpm / 60000) * 2 * Math.PI;
          const val = (Math.sin(phase) + 1) / 2; // 0..1
          const scale = 0.04 + val * 0.96; // match beatsin8 10..255 approx
          const base = hexToRgb(cfg.effectColor || 'ffffff');
          const scaled = {r: base.r*scale, g: base.g*scale, b: base.b*scale};
          dots.forEach(d => { d.style.backgroundColor = rgbToCss(scaled); });
        } else if(eff === 'xmas'){
          const stepMs = ((320 - 80) * (20 - speedVal) / 19) + 80; // map 1..20 -> ~320..80
          const chance = ((120 - 20) * (speedVal - 1) / 19) + 20; // map 1..20 -> 20..120
          const nowTs = performance.now();
          if(!previewInterval._lastXmasTs) previewInterval._lastXmasTs = nowTs;
          if(!Array.isArray(previewTwinkle) || previewTwinkle.length !== LED_COUNT){
            previewTwinkle = new Array(LED_COUNT).fill({r:0,g:0,b:0});
          }
          if(nowTs - previewInterval._lastXmasTs >= stepMs){
            previewInterval._lastXmasTs = nowTs;
            const palette = [
              {r:255,g:0,b:0},
              {r:0,g:255,b:0},
              {r:255,g:215,b:0},
              {r:0,g:0,b:255}
            ];
            previewTwinkle = previewTwinkle.map(c=>({
              r: Math.max(0, c.r - 40),
              g: Math.max(0, c.g - 40),
              b: Math.max(0, c.b - 40)
            }));
            for(let i=0;i<LED_COUNT;i++){
              if(Math.random()*256 < chance){
                const p = palette[Math.floor(Math.random()*palette.length)];
                previewTwinkle[i] = {...p};
              }
            }
          }
          dots.forEach((d, idx)=>{ d.style.backgroundColor = rgbToCss(previewTwinkle[idx]); });
        } else { // default rainbow fallback
          previewHue = (previewHue + step) % 256;
          dots.forEach((d, idx)=>{
            const hue = ((previewHue + idx*3) % 256) * (360/255);
            d.style.backgroundColor = hsvToCss(hue,1,1);
          });
        }
      }, 30);
    }

    function buildConfigPayload(form){
      const hours = [];
      for(let i=0;i<7;i++){
        const val = form[`h${i}`]?.value || '00:00-00:00';
        const [start,end] = val.split('-');
        hours.push({start:start||'00:00', end:end||'00:00'});
      }
      const icals = (icalEntries||[]).filter(e=>e.url && e.url.trim().length>0).slice(0,5).map(e=>({
        url: e.url.trim(),
        color: (e.color||'').replace('#','') || (form.appointmentColor.value.replace('#',''))
      }));
      return {
        ledCount: LED_COUNT,
        brightness: Math.round(Number(form.brightness.value) / 100 * 255),
        mode: getSelectedMode(),
        effect: form.effect.value,
        effectSpeed: Number(form.effectSpeed.value),
        effectColor: form.effectColor.value.replace('#',''),
        tz: form.tz.value,
        icals,
        enableAppointments: form.enableAppointments.checked,
        enableOpenHours: form.enableOpenHours.checked,
        notifyMinutesBefore: Number(form.notifyMinutesBefore.value),
        openColor: form.openColor.value.replace('#',''),
        closedColor: form.closedColor.value.replace('#',''),
        appointmentColor: form.appointmentColor.value.replace('#',''),
        clockColor: form.clockColor.value.replace('#',''),
        hours
      };
    }

    async function postConfig(payload, {silent = true} = {}){
      try {
        const res = await fetch('/api/config',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
        if(!res.ok && !silent){
          alert('Speichern fehlgeschlagen: HTTP ' + res.status);
        }
      } catch(err){
        if(!silent) alert('Speichern fehlgeschlagen: ' + err.message);
      }
    }

    function scheduleAutoSave(){
      if(isLoadingConfig) return; // avoid firing while applying fetched config
      if(autoSaveTimer) clearTimeout(autoSaveTimer);
      autoSaveTimer = setTimeout(()=>{
        const form = document.getElementById('cfgForm');
        const payload = buildConfigPayload(form);
        latestConfig = payload; // keep preview in sync without reload
        updateLedPreview();
        postConfig(payload, {silent:true});
      }, 400);
    }

    async function loadConfig(){
      isLoadingConfig = true;
      const res = await fetch('/api/config');
      const cfg = await res.json();
      const form = document.getElementById('cfgForm');
      form.brightness.value = Math.round((cfg.brightness || 0) / 255 * 100);
      brightnessLabel.textContent = `${form.brightness.value}%`;
      const modeVal = cfg.mode || 'clock';
      modeRadios.forEach(r=>{ r.checked = (r.value === modeVal); });
      syncModePills();
      form.effect.value = cfg.effect || 'rainbow';
      form.effectSpeed.value = cfg.effectSpeed ?? 4;
      effectSpeedLabel.textContent = form.effectSpeed.value;
      form.effectColor.value = `#${cfg.effectColor || 'ffffff'}`;
      form.tz.value = cfg.tz;
      form.openColor.value = `#${cfg.openColor || '00ff00'}`;
      form.closedColor.value = `#${cfg.closedColor || 'ff0000'}`;
      form.appointmentColor.value = `#${cfg.appointmentColor || '00ffff'}`;
      document.getElementById('newAppointmentColor').value = `#${cfg.appointmentColor || '00ffff'}`;
      form.enableAppointments.checked = cfg.enableAppointments ?? true;
      form.enableOpenHours.checked = cfg.enableOpenHours ?? true;
      form.clockColor.value = `#${cfg.clockColor || 'ffffff'}`;
      form.notifyMinutesBefore.value = cfg.notifyMinutesBefore ?? 30;
      icalEntries = Array.isArray(cfg.icals) ? cfg.icals.slice(0,5) : [];
      if(icalEntries.length === 0 && cfg.icalUrl){
        icalEntries.push({url: cfg.icalUrl, color: cfg.icalColor || cfg.appointmentColor || '00ffff'});
      }
      icalEntries = icalEntries.map(e=>({url: e.url || '', color: (e.color||cfg.appointmentColor||'00ffff').replace('#','')}));
      renderIcalList();
      buildHours(cfg.hours);
      updateModeVisibility();
      latestConfig = cfg;
      updateLedPreview();
      isLoadingConfig = false;
    }

    modeRadios.forEach(r=>r.addEventListener('change', ()=>{ updateModeVisibility(); scheduleAutoSave(); }));
    effectSelect.addEventListener('change', updateModeVisibility);

    document.querySelector('input[name="brightness"]').addEventListener('input', (e)=>{
      brightnessLabel.textContent = `${e.target.value}%`;
      scheduleAutoSave();
    });

    document.querySelector('input[name="effectSpeed"]').addEventListener('input', (e)=>{
      effectSpeedLabel.textContent = e.target.value;
      scheduleAutoSave();
    });

    document.getElementById('btnAddIcal').addEventListener('click', ()=>{
      const url = newIcalUrl.value.trim();
      if(!url) return alert('Bitte iCal URL eintragen');
      if(icalEntries.length >= 5) return alert('Maximal 5 Kalender');
      icalEntries.push({url, color: newIcalColor.value.replace('#','')});
      newIcalUrl.value = '';
      renderIcalList();
      scheduleAutoSave();
    });

    document.getElementById('cfgForm').addEventListener('input', scheduleAutoSave);
    document.getElementById('cfgForm').addEventListener('change', scheduleAutoSave);

    function escapeHtml(str){
      return str.replace(/[&<>"]/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[s]));
    }

    function updateClockNow(){
      const d = new Date();
      clockNowEl.textContent = d.toLocaleTimeString('de-DE', {hour:'2-digit', minute:'2-digit'});
      dateNowEl.textContent = d.toLocaleDateString('de-DE', {weekday:'short', day:'2-digit', month:'2-digit', year:'numeric'});
    }

    let updateStatusTimer;
    let updateProgressTimer;
    let updateStartTs = 0;

    function stopUpdateTimer(){
      if(updateProgressTimer){
        clearInterval(updateProgressTimer);
        updateProgressTimer = null;
      }
      updateProgressEl.textContent = '';
      updateProgressEl.classList.add('hidden');
      updateStartTs = 0;
    }

    function startUpdateTimer(){
      stopUpdateTimer();
      updateStartTs = Date.now();
      updateProgressTimer = setInterval(()=>{
        const sec = Math.floor((Date.now() - updateStartTs)/1000);
        const mins = Math.floor(sec / 60);
        const secs = sec % 60;
        const warn = sec > 90 ? ' (kann mehrere Minuten dauern, geduldig warten)' : '';
        updateProgressEl.textContent = `Laufzeit: ${mins}:${secs.toString().padStart(2,'0')} – Fortschritt im Seriell-Log ansehen${warn}.`;
        updateProgressEl.classList.remove('hidden');
      }, 1000);
    }

    function setUpdateStatus(text = '', tone = 'info', clearAfterMs = 0){
      if(updateStatusTimer){
        clearTimeout(updateStatusTimer);
        updateStatusTimer = null;
      }
      if(!text){
        updateStatusEl.textContent = '';
        updateStatusEl.classList.add('hidden');
        return;
      }
      updateStatusEl.textContent = text;
      updateStatusEl.style.color = tone === 'error' ? '#b91c1c' : '#0f172a';
      updateStatusEl.classList.remove('hidden');
      if(clearAfterMs > 0){
        updateStatusTimer = setTimeout(()=>setUpdateStatus('', tone, 0), clearAfterMs);
      }
      if(tone === 'error') stopUpdateTimer();
    }

    async function loadLatestRelease(){
      releaseInfo.textContent = 'Lade...';
      try {
        const res = await fetch('https://api.github.com/repos/dani251198/led-sign/releases/latest', {headers:{'Accept':'application/vnd.github+json'}});
        if(!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        const notes = escapeHtml(data.body || 'Keine Release Notes');
        const assetFw = (data.assets || []).find(a => /firmware\.bin/i.test(a.name));
        const assetFs = (data.assets || []).find(a => /littlefs\.bin/i.test(a.name));
        const fwUrl = assetFw ? assetFw.browser_download_url : '';
        const fsUrl = assetFs ? assetFs.browser_download_url : '';
        releaseInfo.innerHTML = `Aktuell: ${fwVersionEl.textContent || '--'}\nVersion: ${data.tag_name || data.name || 'n/a'}\nDatum: ${(data.published_at || '').substring(0,10)}\nNotes:\n${notes}${fwUrl ? `\nFirmware: ${assetFw.name}` : '\nKeine Firmware-Asset gefunden'}${fsUrl ? `\nFilesystem: ${assetFs.name}` : '\nKein Filesystem-Asset gefunden'}`;
        releaseInfo.dataset.fwUrl = fwUrl;
        releaseInfo.dataset.fsUrl = fsUrl;
        btnReleaseFlash.disabled = !fwUrl;
        if(fwUrl) btnReleaseFlash.textContent = fsUrl ? `Neueste Release flashen (FW+FS ${data.tag_name || ''})` : `Neueste Release flashen (nur FW ${data.tag_name || ''})`;
      } catch(err){
        releaseInfo.textContent = 'Fehler: ' + err.message;
        releaseInfo.dataset.fwUrl = '';
        releaseInfo.dataset.fsUrl = '';
        btnReleaseFlash.disabled = true;
      }
    }

    btnReleaseInfo.addEventListener('click', loadLatestRelease);

    function toIsoFromGerman(val){
      // Accept DD.MM.YYYY HH:MM and fallback to passthrough
      const parts = val.trim().split(' ');
      if(parts.length !== 2) return val;
      const [dmy, hm] = parts;
      const d = dmy.split('.');
      if(d.length !== 3) return val;
      const [dd, mm, yyyy] = d;
      if(dd.length < 1 || mm.length < 1 || yyyy.length !== 4) return val;
      return `${yyyy}-${mm.padStart(2,'0')}-${dd.padStart(2,'0')} ${hm}`;
    }

    function toGermanDisplay(val){
      // Expect YYYY-MM-DD HH:MM
      if(!val || val.length < 16) return val;
      const date = val.substring(0,10).split('-');
      if(date.length !== 3) return val;
      const [y,m,d] = date;
      const hm = val.substring(11,16);
      return `${d}.${m}.${y} ${hm}`;
    }

    async function loadAppointments(){
      const res = await fetch('/api/appointments');
      const arr = await res.json();
      apptListEl.innerHTML = '';
      if(!Array.isArray(arr) || arr.length === 0){
        apptListEl.textContent = 'Keine Termine gesetzt.';
        return;
      }
      const list = document.createElement('ul');
      arr.forEach((t, idx)=>{
        const li = document.createElement('li');
        const color = t.color ? `#${t.color}` : `#${(latestConfig?.appointmentColor)||'00ffff'}`;
        const swatch = document.createElement('span');
        swatch.style.display = 'inline-block';
        swatch.style.width = '12px';
        swatch.style.height = '12px';
        swatch.style.marginRight = '6px';
        swatch.style.borderRadius = '3px';
        swatch.style.background = color;
        li.appendChild(swatch);
        li.appendChild(document.createTextNode(toGermanDisplay(t.time || t)));
        const btn = document.createElement('button');
        btn.textContent = 'Löschen';
        btn.className = 'btn-danger';
        btn.style.marginLeft = '8px';
        btn.addEventListener('click', async ()=>{
          const res = await fetch('/api/appointments',{method:'DELETE', headers:{'Content-Type':'application/json'}, body: JSON.stringify({index: idx})});
          if(res.ok) loadAppointments();
          else alert('Konnte Termin nicht löschen');
        });
        li.appendChild(btn);
        list.appendChild(li);
      });
      apptListEl.appendChild(list);
    }

    async function loadStatus(){
      try{
        const res = await fetch('/api/status');
        const st = await res.json();
        statusEl.textContent = st.wifi ? `Online: ${st.ip}` : 'Offline';
        fwVersionEl.textContent = st.version || '--';
        latestStatus = st;
        updateLedPreview();
        renderIcalNext();
      } catch(err){
        statusEl.textContent = 'Keine Verbindung';
        fwVersionEl.textContent = '--';
      }
    }

    document.getElementById('cfgForm').addEventListener('submit', async (e)=>{
      e.preventDefault();
      const form = e.target;
      await postConfig(buildConfigPayload(form), {silent:false});
      alert('Gespeichert.');
    });

    document.getElementById('btnAddAppt').addEventListener('click', async ()=>{
      const val = document.getElementById('newAppointment').value.trim();
      const colorVal = document.getElementById('newAppointmentColor').value.replace('#','');
      if(!val) return alert('Bitte Termin angeben');
      const iso = toIsoFromGerman(val);
      const res = await fetch('/api/appointments',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({time: iso, color: colorVal})});
      if(res.ok){
        document.getElementById('newAppointment').value = '';
        loadAppointments();
      } else {
        alert('Termin ungültig oder Liste voll (max 10).');
      }
    });

    async function flashRelease(){
      setUpdateStatus('Lade Release-Infos...', 'info');
      btnReleaseInfo.disabled = true;
      btnReleaseFlash.disabled = true;
      try {
        await loadLatestRelease();
        const fwUrl = releaseInfo.dataset.fwUrl;
        const fsUrl = releaseInfo.dataset.fsUrl;
        if(!fwUrl){
          setUpdateStatus('Keine Firmware-URL gefunden.', 'error');
          return;
        }
        setUpdateStatus(`Starte Update...\nFW: ${fwUrl}${fsUrl ? `\nFS: ${fsUrl}` : ''}`, 'info');
        startUpdateTimer();
        const res = await fetch('/api/update_bundle',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({fwUrl, fsUrl})});
        if(res.ok){
          const body = await res.text();
          setUpdateStatus('Download/Flash läuft – Gerät rebootet gleich. Bitte ca. 1 Minute warten.\nAntwort: ' + body, 'info', 80000);
        } else {
          const body = await res.text();
          setUpdateStatus(`Update fehlgeschlagen: HTTP ${res.status}${body ? ` – ${body}` : ''}`, 'error');
        }
      } catch(err){
        setUpdateStatus('Update fehlgeschlagen: ' + err.message, 'error');
      } finally {
        stopUpdateTimer();
        btnReleaseInfo.disabled = false;
        btnReleaseFlash.disabled = !releaseInfo.dataset.fwUrl;
      }
    }

    btnReleaseFlash.addEventListener('click', flashRelease);

    document.getElementById('btnWifiReset').addEventListener('click', async ()=>{
      if(!confirm('Wirklich WLAN-Zugangsdaten löschen und neu starten?')) return;
      const res = await fetch('/api/wifi/reset',{method:'POST'});
      if(res.ok){ alert('Gerät startet neu und öffnet das Setup-WLAN.'); }
      else { alert('Konnte WLAN-Reset nicht ausführen.'); }
    });

    loadConfig();
    loadAppointments();
    loadStatus();
    updateClockNow();
    setInterval(loadStatus, 5000);
    setInterval(updateClockNow, 1000);
  </script>

  <p style="margin-top:24px; color:#475569; font-size:13px; text-align:center;">
    Made with ♥️ through vibe coding and GPT-5.1-Codex-Max by Dan und Sammy
  </p>
</body>
</html>
